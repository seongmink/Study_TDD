# 테스트 주도 개발

## 흔한 소프트웨어 개발 방식

![](../images/1-1.jpg)

고전적인 개발 방식에서 아래와 같은 문제점이 나타난다.

1. ##### 특정 모듈의 개발 기간이 길어질수록 개발자의 목표의식이 흐려진다.

2. ##### 작업 분량이 늘어날수록 확인이 어려워진다.

3. ##### 개발자의 집중력이 필요해진다.

4. ##### 논리적인 오류를 찾기가 어렵다.

5. ##### 코드의 사용 방법과 변경 이력을 개발자의 기억력에 의존하게 되는 경우가 많다.

6. ##### 테스트 케이스가 적혀 있는 엑셀 파일을 보며 매번 테스트를 실행하는 게 점점 귀찮아져서 점차 간소화하는 항목들이 늘어난다.

7. ##### 코드 수정 시에 기존 코드의 정상 동작에 대한 보장이 어렵다.

8. ##### 테스트를 해보려면 소스코드에 변경을 가하는 등, 번거로운 선행 작업이 필요할 수 있다.

9. ##### 그래서 소스 변경 시 해야 하는 회귀 테스트는 곧잘 희귀 테스트(rare test)가 되기 쉽다.

10. ##### 이래저래 테스트는 개발자의 귀중한 노동력(man-month)을 적지 않게 소모한다.

해당 문제를 제거하기 위해, 여러 방법을 거쳤다. 그래도 문제 발생 확률을 낮춰줄 수 있는 여러 가지 기법 중 하나가 테스트를 개발의 전면으로 내세운 **TDD**이다.

## 테스트 주도 개발(TDD)

> 프로그램을 작성하기 전에 테스트 먼저 하라!
>
> (Test the program before you write it.) - 켄트 백(Kent Beck)

TDD의 정의는 곧잘 아래와 같이 이야기 되곤 한다.

**"업무 코드를 작성하기 전에 테스트 코드를 먼저 만드는 것!"**

코드를 검증하는 테스트  코드를 먼저 만든 다음에 실제 작성해야 하는 프로그램 코드 작성에 들어가라는 뜻이다. 최초에는 테스트 우선 개발(Test First Development)이라고 불렸으나 지금은 테스트 주도 개발(Test-Driven Development, TDD)이라 불린다. 메소드나 함수 같은 프로그램 모듈을 작성할 때 '작성 종료조건을 먼저 정해놓고 코딩을 시작한다'는 의미로 받아들이면 된다. 예를 들어, 두 숫자의 합을 구해서 반환해야 하는 sum이라는 메소드를 작성한다고 가정하면

| 설명                                | 내용                                                        |
| ----------------------------------- | ----------------------------------------------------------- |
| 작성 메소드 이름                    | sum                                                         |
| 기능 구현에 필요한 재료(argument)   | int a, int b                                                |
| 반환 값의 타입                      | int                                                         |
| 정상 동작 만족 조건(작성 종료 조건) | a와 b를 더한 값을 결과로 돌려줌, 즉 sum(10, 15)는 25를 리턴 |

우리가 프로그램을 작성할 때 머릿속으로 생각하는 내용과 별반 다르지 않다. 다만 **'문서로 만들어 머리로 생각하고 눈으로 확인할 것인가?'** 아니면, **'예상 결과를 코드로 표현해놓고 해당 코드가 자동으로 판단하게 할 것인가?'**의 차이가 있다. 위 설계문서에 따라 sum 메소드를 작성할 때, 코드를 통해 정상적으로 구현됐는지 판단하는 방법을 선택한다면 아래와 같은 코드로 작업할 수도 있다.

```java
public class Calculator {
    public int sum(int a, int b) {
        return 0;
    }
    
    public static void main(String[] args) {
        
        Calculator calc = new Calculator();
        System.out.println(calc.sum(10, 20) == 30);
        System.out.println(calc.sum(1, 2) == 3);
        System.out.println(calc.sum(-10, 20) == 10);
        System.out.println(calc.sum(0, 0) == 0);
    }
}
```

```
-----실행 결과-----
false
false
false
true
```

위 예제에서는 main 메소드를 테스트 메소드처럼 사용했다. sum 메소드는 컴파일 에러만 나지 않도록 해놓고, 내부는 비어 있는 상태이다. sum 메소드를 먼저 구현한 다음에 테스트를 할 수도 있지만, 그렇게 하지 않고 검증코드를 먼저 만들어놓았다. 그 검증코드에 해당하는 테스트 케이스를 모두 만족하면, 즉 main 메소드의 실행 결과가 모두 true로 나오면 sum 메소드가 정상적으로 작성됐다고 판단하기로 한 것이다. 다시 말해, 명시적인 코드로 개발 종료조건을 정해놓은 것이다. 이런식의 개발 접근 방식이 바로, TDD이다. 테스트 케이스 작성으로 구현을 시작하는 것, 그게 바로 TDD이다.

## 테스트 주도 개발의 목표

> 잘 동작하는 깔끔한 코드
>
> (Clean code that works) - 론 제프리(Ron Jeffries)

우리가 TDD라는 방식을 얻고자 하는 최종 목적은 '잘 동작하는 깔끔한 코드'이다. 이는 일반적인 소프트웨어 개발의 목표와 별반 다르지 않다. 다만 TDD에선 정상적으로 동작하는 코드만을 개발의 목표로 삼지 않고, 작성된 코드도 명확한 의미를 전달할 수 있게 작성돼야 한다고 말한다. 즉, '제대로 동작함(works)'뿐 아니라 '깔끔함(clean)'까지도 동등한 수준의 개발 목표로 삼는다는 점이 일반적인 개발 방식과 다르다. 이 차이점은 소프트웨어의 품질을 비롯한 유지보수의 편의성, 가독성, 그리고 그에 따른 소프트웨어의 비용과 안정성 등 여러 가지 측면의 의미를 내포한다.

## 테스트 주도 개발 진행 방식

1. 질문(Ask) : 테스트 작성을 통해 시스템에 질문한다.(테스트 수행 결과는 실패)
2. 응답(Respond) : 테스트를 통과하는 코드를 작성해서 질문에 대답한다. (테스트 성공)
3. 정제(Refine) : 아이디어를 통합하고, 불필요한 것은 제거하고, 모호한 것은 명확히 해서 대답을 정제한다.(리팩토링)
4. 반복(Repeat) : 다음 질문을 통해 대화를 계속 진행한다.

TDD를 이용한 개발은 크게 **'질문 -> 응답 -> 정제'**라는 세 단계가 반복적으로 이루어진다.

![](../images/1-2.jpg)

TDD는 이와 같은 형태의 반복적인 흐름을 갖는다. 흔히 단위 테스트 프레임워크(Unit Test Framework)를 사용한 테스트 코드 작성이 이뤄진다고 생각하면 된다.

## 실습 먼저 시작해보기

은행 계좌(Account Class) 클래스를 TDD 방식으로 만들어보자.

```
은행계좌 클래스
 - 계좌 잔고 조회
 - 입금/출금
 - 예상 복리 이자(추가 개발)
```

은행계좌(Account) 클래스를 만들어야 한다고 판단됐으며, 기능 요구사항은 위와 같다고 가정한다. 잔고 조회가 가능해야 하고, 입금과 출금을 관리할 수 있어야 한다. 위 내용을 **'질문 -> 응답 -> 정제'**의 단계를 밟아가며, 실습을 진행해보자.

- ### 첫 번째 질문 : 계좌 생성 테스트

  - 구현해야 할 기능을 파악하고, 목록을 작성한다.
  - 계좌 생성 기능을 구현하기 위한 최초의 테스트 케이스를 만들고 실패하는 모습을 확인한다.

  일반적인 소프트웨어의 갭라이 긴응르 구현하고 테스트를 수행하는 형태라고 한다면,  TDD에서는 그와 반대로 진행된다. TDD에는 테스트의 최소 작성 단위를 최하위 모듈의 단위와 일치시킨다. Java 언어 기준으로 최하위 모듈은 '메소드'다. 가장 처음에 해야하는 단계인 질문(ask) 단계에서는 바로 이 메소드 수준의 단위 테스트를 작성하게 된다. 질문 단계에서 실제로 해야하는 일은 **'작성하고자 하는 메소드나 기능이 무엇인지 선별하고 작성 완료 조건을 정해서 실패하는 테스트 케이스를 작성하는 것'**이다. 클래스 설계서 같은 산출물이 있는 경우라면, 크게 고민할 것 없이 메소드 외양부터 만들기 시작하면 된다. 이때 리턴 타입은 기본 초기값(null, 0 등등) 위주로 설정해놓으면 편하다.

  만약 넘겨밭은 산출물이 없다면 개발에 필요한 모든 내용을 개발자가 스스로 머릿속에 떠올려야 하므로 힘들다. 이럴 떄는 우선 대략적인 설계를 먼저 진행한 다음에 질문 단계를 시작한다.

  구현해야 하는 기능과 유의사항을 생각나는 대로 적어보면 다음과 같다.

  ```
  클래스 이름은 Account
  기능은 세 가지
   - 잔고 조회
   - 입금
   - 출금
  * 금액은 원 단위로(예: 천원 = 1000)
  ```

  어느 정도 준비가 됐으면 테스트 케이스를 작성해본다. 보통 이때 두 가지 접근 방식을 이용할 수 있다.

  1. 구현 대상 클래스의 외형에 해당하는 메소드를 먼저 만들고 테스트 케이스를 일괄적으로 만드는 방식
  2. 테스트 케이스를 하나씩 추가해나가면서 구현 클래스를 점진적으로 만드는 방식

  첫 번째 방식을 사용했을 경우에는, 모든 테스트가 정상 통과하는 올 그린(All Green) 상태에 이르기까지 긴 시간이 걸릴 수 있다.

  우선 적당한 이름으로 Java 프로젝트를 생성한다.
  
  ```java
  package test;
  
  public class AccountTest {
  
  }
  ```
  
  테스트 클래스를 만들었으니 이제 테스트 케이스를 만들어보자. 테스트 케이스는 테스트하고자 하는 대상에 대해 간단한 시나리오를 만들고 그것을 코드로 표현한 모습이다. 우선 계좌 생성에 대한 테스트 시나리오는 다음과 같다.
  
  ```
  계좌를 생성한다. -> 계좌가 정상적으로 생성됐는지 확인한다.
  ```
  
  TDD에서는 하나의 테스트 케이스가 하나의 기능을 테스트하도록 만드는 것이 기본 원칙이다. 그리고 대부분의 경우 하나의 테스트 케이스는 하나의 메소드로 표현된다. 이 메소드를 테스트 메소드라고 부른다. 
  
  ```java
  package test;
  
  public class AccountTest {
  	
  	public void testAccount() {
  		Account account = new Account();
  	}
  }
  
  ```
  
  계좌 생성을 테스트하기 위해 만든 메소드이므로 이름을 testAccount()라고 지었다. 그리고 시나리오의 첫 부분인 '계좌를 생성한다' 부분을 코드로 기술했다. Account 클래스를 만든 적이 없으니 에러가 나는 것이 당연하다. 테스트 시나리오를 코드로 기술하는 작업을 먼저 마치고, 그 다음에 해결한다. (테스트 케이스 작성 시 흐름을 잃지 않기 위해서)
  
  이어서 계좌가 정상적으로 생성됐는지 확인하는 부분을 추가한다.
  
  ```java
  package test;
  
  public class AccountTest {
  	
  	public void testAccount() {
  		Account account = new Account();
  		if(account == null) {
  			throw new Exception("계좌 생성 실패");
  		}
  	}
  }
  
  ```
  
  만일 testAccount() 메소드를 실행했을 때 어떤 문제나 메시지도 발생하지 않는다면, 계좌 생성에 대한 테스트가 성공한 것으로 간주한다. 
  
  main 메소드를 이용하는 것이 제일 간단하므로, 테스트 케이스를 실행하는 main 메소드를 작성해보자.
  
  ```java
  package test;
  
  public class AccountTest {
  	
  	public void testAccount() {
  		Account account = new Account();
  		if(account == null) {
  			throw new Exception("계좌 생성 실패");
  		}
  	}
  	
  	public static void main(String[] args) {
  		AccountTest test = new AccountTest();
  		test.testAccount();
  	}
  }
  
  ```
  
- ### 첫 번째 응답 : 계좌 생성 메소드 구현

  - 계좌 생성 테스트 케이스를 통과하는 코드를 작성한다.

  방금 전 실행했던 테스트 케이스는 에러와 함께 실패했다. 즉, 질문에 대한 시스템의 응답(Response)은 실패(Fail)다. 이번엔 테스트를 성공시켜 보자.

  먼저, Account 클래스를 생성한다.

  ```java
  package main;
  
  public class Account {
  
  }
  ```

  그리고 AccountTest 클래스를 다음과 같이 수정한다.

  ```java
  package test;
  
  import main.Account;
  
  public class AccountTest {
  	
  	public void testAccount() throws Exception {
  		Account account = new Account();
  		if(account == null) {
  			throw new Exception("계좌 생성 실패");
  		}
  	}
  	
  	public static void main(String[] args) {
  		AccountTest test = new AccountTest();
  		try {
  			test.testAccount();
  		} catch (Exception e) {
  			System.out.println("실패(X)");
  			return;
  		}
  		System.out.println("성공(O)");
  	}
  }
  ```

  try 구문 안에서 예외가 발생하면 '실패(X)'라고 출력하고, main 메소드를 종료한다. 예외가 발생하지 않으면 '성공(O)'이라고 출력한다. main 메소드를 실행해보면 성공하는 것을 알 수 있다.

  질문(Ask)에 대답하는 응답(Respond) 단계를 마쳤다. 이제 한 주기의 마지막 단계인 정제(Refine) 단계로 들어간다.

- ### 최초의 정제

  - 리팩토링을 적용할 부분이 있는지 찾아본다.
  - ToDo 목록에서 완료된 부분을 지운다.

  한 주기가 끝나기 전에 소스를 정제해보자. 보통 이 단계에서 리팩토링(refactoring) 작업을 수행한다. 리팩토링은 쉽게 말하면, 정상적으로 동작하는 코드를 수정해서, '사람'이 좀 더 '이해하기 쉽고', '변경하기 용이'한 구조로 소스코드를 개선하는 작업을 지칭한다. TDD에서는 한 주기의 마지막 단계로 정제 단계를 만들어 놓고 리팩토링을 권장하고 있다. 리팩토링을 수행하게 되는 정제 단계에서는 일반적으로 다음과 같은 질문에 대해 고민해보는 시간을 갖는다.

  1. **소스의 가독성이 적절한가?**
  2. **중복된 코드는 없는가?**
  3. **이름이 잘못 부여된 메소드나 변수명은 없는가?**
  4. **구조의 개선이 필요한 부분은 없는가?**

  위와 같은 질문을 해보면서, 앞서 작성한 테스트 케이스에 의존해 소스를 가다듬는 단계가 정제 단계이다.

  ```
  클래스 이름은 Account
  기능은 세 가지
   - 잔고 조회
   - 입금
   - 출금
  * 금액은 원 단위로(예: 천원 = 1000)
  ```

  여기서 클래스 Account 단계가 끝났다.(한 주기를 마침) 이제, 현재 코드에 JUnit 단위 테스트 프레임워크를 적용해보자.

