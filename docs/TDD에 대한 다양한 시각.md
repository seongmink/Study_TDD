# TDD에 대한 다양한 시각

## TDD와 소프트웨어 디자인

### TDD가 주는 설계상의 이점

소프트웨어를 개발하는 건 쉬운 일이 아니다. 특히, 개발 범위 및 규모가 클수록, 그리고 해당 도메인의 업무가 복잡다단할수록 어지러운 코드가 많이 양산되어 넘어서기 어려운 수준(insurmountable chaos level)의 개발 난이도를 만들어내기 쉽다. 결국 혼란 속에서 자멸하거나 누더기가 돼서는 건드릴 수 없게 변한다. 동작은 하지만 만지면 곧잘 깨져버리는 유약한 소프트웨어가 된다는 이야기다. 이런 상황에서 TDD는 어떤 설계상의 이점을 줄 수 있을까? TDD로 개발을 하면 TDD 자체가 단위 단위의 작은 설계를 만들어낸다. 입력과 출력, 그리고 해당 모듈이 동작하기 위해 필요한 요소 파악 등이 사전에 확실하게 고려되고 테스트된다. 그렇게 만들어지는 모습을 강형 마이크로 디자인(Robust Micro Design)이라고 한다. 이런 디자인의 특징 중 하나는 다른 모듈에 대한 의존성이 상대적으로 적다는 점이다. 왜냐하면 다른 모듈에 의존성이 많아지면 적절한 테스트 케이스를 작성하기가 점점 어려워지기 때문에, 개발자가 스스로 모듈의 의존성을 줄이려는 노력을 초반부터 해나가게 된다. 또한 각 모듈은 최대한 테스트를 독립적으로 수행할 수 있도록 만들기 때문에 자기 완결성(self completeness)이 높은 모듈이 된다. 결과적으로 신뢰수준을 따져봐야 하는 모듈에 대해, 개발자가 접근해야 하는 영역을 좀 더 추상화된 상위 레벨로 올려줄 수 있기 때문에, 소프트웨어의 복잡도가 낮아지고 개발자가 좀 더 일반화되고 추상화된 형태의 디자인에 더 집중할 수 있게 도와준다. 

### TDD와 객체 지향 프로그래밍(OOP)

OOP에서는 모듈화가 굉장히 강조되고 있고, 대부분의 객체 지향 프로그래밍 언어는 모듈화를 지원하는 기능을 기본적으로 내장하고 있다. 이를테면 클래스나 패키지, 인터페이스 등이 그런 요소다. OOP가 각광받고 유독 모듈화가 강조되는 이유는 '**안전한 부품**' 그리고 '**재사용성**'을 높여주는 요소를 좀 더 쉽게 만들 수 있기 때문이다. 그리고 그걸 이루기 위해 최대한 따라야 하는 가이드로, OOP의 원칙이라는 것이 있다. 그런 OOP의 근간이 되는 기초 원칙 중에는 '**모듈(module)은 높은 응집도(high cohesion)를 유지하고 낮은 결합도(loose coupling)를 갖도록 만들어야 한다**'는 원칙이 있다. 아주 중요한 OOP의 핵심 원칙 중 하나다. 수많은 개발자들이 객체 지향 언어를 사용해서 절차적 프로그래밍을 하고 있다. 또 설사, 위 원칙을 염두에 두고 설계를 하고 코드를 작성했다 하더라도, 정말 잘 따르고 있는 건지, 따랐다면 해당 모듈이 어느 정도 레벨의 응집도와 결합도를 갖고 있는지 판단하기가 쉽지 않다.

어느 회사에서 직원의 연봉을 구하는 프로그램 모듈을 작성한다고 가정해보자. 만일 객체 지향 설계를 하라고 한다면 많은 경우 클래스부터 만들려고 할 것이다. 아쉽지만 그건 별로 좋은 방법이 아니다. 또 그 다음엔 여러 모듈(클래스)을 만들어서 이용할 수 있는 한 최대한 재사용하려고 노력할 것이다. 그러다 보면 다음과 같은 코드도 서슴지 않고 나온다. 코드가 무슨 내용인지 크게 집중할 필요는 없다. 그냥 코드의 구조만 보자. 그리고 이어지는 두 코드는 서로 관련 없는 각각의 코드다.

##### 예 1

```java
public class MeasureCounter {
    
    public String getTotalMeasure(String name){
        Stock b = new Stock(name); // 객체 생성
        int firstCountRate = b.getFirstCountRate(); // 최초 비율
        int runningCount = b.getRunningCount()/2; // 러닝카운트
        int remainingCount = b.getRemainings(); // 남은 수량
        return name + ": " + (firstCountRate + runningCount + remainingCount);
    }
    ...
}
```

##### 예 2

```java
public class PublicItem {
    public int getDualCharge(Sender sender){
        int fare = 0; // 요금
        if ( this.item.getStore().getCustomer(sender.getName()).isVip() ){
            fare = sender.getBox().getFare() * 0.8;
        } else {
            fare = sender.getBox().getFare();
        }
        return fare;
    }
    ...
}
```

그나마 깔끔하게 작성한다고 한 코드다. 그리고 잘 동작한다. '아, Java로 짰고, 잘 동작하고, 눈으로 보기에도 별로 복잡하지 않고, 간결한게 아주 마음에 드네!'라는 생각이 들 수도 있다. 하지만 그러면 안 된다. 만일 뭐가 잘못된 코드인지 잘 모르겠다면 큰일이다. 고무적인 사실은, 위 두 코드는 TDD로 만들었다면 좀처럼 쉽게 만들어지지 않았을 코드라는 점이다. 우선 첫 번째 코드부터 보자. getTotalMeasure()라는 메소드를 작성하기 위해 TDD로 작성한다고 가정해보자. 테스트 코드 입장에서 미리 준비 가능한 건 name뿐이다. name을 넣으면 해당 이름에 해당하는 Stock의 특정 정보들을 알려주는 기능을 만들면 될 것 같다.

> 아, 잠깐! 그런데 TotalMeasure를 구하려면 Stock 관련 정보가 있어야 할 것 같은데, 내 클래스 안에는 없잖아! 그럼, Stock 관련 정보는 어디에 있는 거지? 아, Stock 클래스에 있지. 잠깐! 이거 뭐야? 내가 테스트하고자 하는 기능들은 대부분이 내 자신의 클래스인 MeasureCounter에 있는 게 아니라, Stock에 있잖아! 여기서 이걸 테스트 하는 게 맞는 걸까?

TDD로 작성을 하게 되면 이런 식으로 기능과 객체의 관계를 스스로 먼저 고민하게 된다. 그리고는 때때로 현재와 같은 클래스 구조로는 테스트 코드를 미리 작성할 수가 없다는 사실을 스스로 알아차리게 된다. 테스트 케이스 코드는 입력과 출력(in/out)이 명확하고, 사용되는 재료가 적으면 적을수록 작성하기가 쉽다. 즉, 의존관계가 많은 코드는 테스트 코드 자체를 만들기가 어렵다. 사람의 본성이란 게, 어려우면 안하게 된다. 의존관계를 최대한 만들지 않고 기능이 동작하도록 노력을 기울이게 된다. TDD는 자신의 모듈에 필요한 게 무엇인지를 미리미리 고민하게 만든다. 기능 위주로 테스트를 하기 때문에 불필요한 속성/필드가 무엇인지도 초반부터 밝혀진다. 따라서 테스트를 작성하다 보면 getTotalMeasure 메소드는 기능이 전적으로 Stock 클래스에 의존하고 있음을 알게 되고 해당 기능을 Stock 클래스를 테스트하는 걸로 변경해야겠다는 생각이 든다. 그리고 결국에 가서는 MeasureCounter 클래스에서 getTotalMeasure가 존재할 필요가 없음을 깨닫게 된다. 이게 바로 응집도를 높이고 결합도를 낮춘 모습이다. 두 번째 소스도 테스트 케이스를 작성하다 보면, 자신의 모듈이 동작하기 위해 필요한 재료를 상당히 멀리서 가져온다는 사실을 테스트 케이스 작성 시에 발견하게 된다.

```java
this.item.getStore().getCustomer(sender.getName()).isVip();
```

진정 자신의 클래스 안에 존재해야 하는 커플링 객체가 item인지 customer인지 다시 한번 고민하도록 유도한다. 왜? 테스트 케이스를 작성하려면 재료가 필요하니까. 그리고 그 재료가 어떻게 쓰이는지 미리 고민해야 하니까. 이렇듯 TDD는 좀 더 나은 설계, 좀 더 나은 모듈 디자인이 될 수 있도록 스스로 생각할 수 있게 유도하고, 결과적으로는 모듈이 더 나은 구조를 가질 수 있게 한다. 

### 유연한 코드

유연한 코드를 만든다는 건 무엇을 의미할까? 흔히 변화에 쉽게 적응할 수 있는 코드 (기능 변경 요구에도 구조가 변경되지 않는 코드)를 유연한 코드라 부른다. 또한, 한편으론 요구사항을 받아들이는 데 개발자의 거부감이 적은 코드를 뜻하기도 한다. 대부분의 경우 개발자의 거부감은 개발자가 다루는 소프트웨어 소스의 복잡도에 기인한다. 코드가 복잡하면, 신경 쓸게 많아지고 민감하게 동작하는 코드가 많아진다. 그래서 복잡한 소스를 수정할 경우 개발자에겐 거부감이 생기게 된다.

이 거부감은 따지고 보면 결국 소프트웨어 실패(failure)에 대한 두려움이다. 그런데 사실 이 부분에선 모순이 존재한다. 소프트웨어의 변경이 쉬워지려면 코드가 유연해야 하는데, 소프트웨어 공학에서 추구하는 유연함(flexibility)이란 때로 '개발비용 증가'의 또 다른 요소가 되기도 한다. 이 비용은 온전히 개발자가 떠안게 되는 비용이다. 지나치게 다양한 선택지가 존재하는 환경은 최적의 선택지를 고를 확률을 떨어뜨린다. 그래서 유연한 코드를 만들어서 변경을 용이하게 만든다는 건, 무수히 많은 레고 조각을 제공해놓고는 "어떠한 모양의 자동차도 만들 수 있다!"라고 말하는 것과 유사하다. 그럼 어떻게 해야 할까? 최대한으로 적절한(reasonable) 선택을 할 수밖에 없다. **현재 필요한 기능에만 최대한 집중**하는 게 여기서 말하는 조금의 노력이고 적절한 선택이다.

개발자는 일반적으로 다음과 같은 감정을 갖는다.

- **한 클래스의 메소드 숫자가 많을수록 복잡하다고 느낀다.**
- 한 시스템의 클래스 개수가 많을수록 복잡하다고 느낀다.

따라서 코드 검사(inspection) 툴이나 동료검토(peer-review)를 통해 스스로 작성한 코드가 적절히 유연한 코드인지 측정해볼 필요가 있다. 이때, 다음과 같은 측정은 제대로 된 측정이라 할 수 없다

- **작성자 자신이 사용한 디자인 패턴들의 목록 감별 시간**
- **작성자 자신이 코드에 변경을 가하는 데 소요되는 시간**

이때 걸리는 노력과 시간으로 코드의 적절한 유연성 여부를 스스로 판단하는 건, 작성자의 지식 수준과 코드 소유욕에 기반한 측정 오류의 흔한 예가 된다. 그것보다는 아래에 해당하는 시간을 측정해보자.

- **시스템에 익숙하지 않은 사람이 새로운 요구사항 반영을 위해 소프트웨어에 변경을 가하는데 소요되는 시간**

이 시간과 노력을 측정하는 것이 적절히 유연한 코드인지를 판단하는 기준으로 좀 더 유 용하다. 그리고 이 원칙은 테스트 케이스를 작성할 때도 마찬가지다.

## TDD 유의사항 

- ### 테스트 케이스는 이름이 중요하다

  TDD에 익숙하지 않고 학습 단계에 있을 때 흔히 간과하는 것 중 하나는, 작성된 테스트를 수행하거나 읽는 사람이 자신 혼자라고 은연중에 가정한다는 점이다. 그러다 보니 무엇을 테스트하는 것인지 테스트 메소드 이름만으로는 알기 어려운 경우가 종종 발생한다. 자신만 알아보기 쉽게 만들었다든가, 아니면 오해의 소지가 있는 단어를 썼기 때문이다. 보통 테스트가 실패하면 실패한 메소드의 이름이 테스트의 기준이 된다. 따라서 테스트의 이름이 잘 작성되어 있어야 실패에 대한 대응을 빠르게 할 수 있다. 또 가끔은, testDeposit_minusCase01, testDeposit_minusCase02 같은 식의 일련번호를 이름에 사용하는 모습을 보곤 한다. 이런 경우도 권장하지 않는다. 테스트 메소드 의 이름이 좀 더 길어지더라도 해당 테스트가 무엇이고 실패한 세부 항목이 무엇인지 곧바로 알 수 있어야 한다. 번호 대신에 의미 있는 이름을 붙여주자. 그리고 경우에 따라서는 테스트 메소드의 이름에 한글을 사용하는 것도 도움이 된다.

  ```
  testWithdraw_마이너스통장_대출한계이상으로_인출요구시();
  testWithdraw_마이너스통장_연체이자미납자_인출요구시();
  ```

  그런데 이렇게 테스트 메소드의 이름을 설명적으로 풀어쓰는 식으로 작성하다 보면 자칫 테스트 메소드의 이름이 길어질 수 있다. 그렇다고 해서 굳이 불편해한다든가, 약어를 써서 줄이려고 한다든가 할 필요는 전혀 없다. 로직을 살펴보지 않고 메소드 이름만으로도 충분히 의미를 전달할 수 있을 정도로 작성하는 것이 중요하다.

- ### 더 이상 제대로 동작하지 않는 테스트 케이스는 제거한다

  자동화된 테스트 메소드는 소스의 품질을 좌우하는 중요한 자산이다. 하지만 그렇다고 해서 많으면 많을수록 무조건 좋은 건 절대 아니다. 중복된 테스트 케이스나 업무 변경 등의 이유로 더 이상 제대로 동작하지 않는 테스트 케이스는 과감하게 제거한다. 소스의 품질과 테스트 케이스의 숫자는 항상 일치하는 게 아니기 때문이다.

- ### TDD는 자동화된 테스트를 만드는 것이 최종 목표가 아니다

  TDD는 개발의 목표 지점을 미리 정하기 위해 단위 테스트 케이스를 만들고, 목표 상태 도달 여부를 빨리 확인하기 위해 단위 테스트 케이스를 자동화시킨다. 자동화된 단위 테스트 케이스들은 TDD의 부산물이다. 개발과 설계를 위한 보조 도구이지 목적은 아니다. 자동화된 테스트는 말 그대로 자동적으로 수행되는 테스트를 의미하고, 소프트웨어의 현재 상태의 정상 여부 판단이 목표이다. 향후 소프트웨어 내부가 변경됐을 때 문제가 없는지를 판단하는데도 물론 사용할 수 있다. 미묘한 차이점인데, 확실히 구분해놓아야 하는 개념이다.

- ###  모든 상황에 대한 테스트 케이스를 만들 필요는 없다

  요구사항에 맞는 현재 필요한 기능에 대한 테스트만 만든다. 개발자가 개발을 하다 보면 종종 지나치게 테스트에 집착하는 경향을 보이다가 어느 순간엔가 지쳐버리는 모습 을 보곤 한다. 'TDD는 힘들고 어렵고 복잡하구나'라고 말이다.

- ### 여러 개의 실패하는 테스트 케이스를 한 번에 만들지 않는다

  개발 중에는, 작성하고 있는 하나의 클래스에 대해서는 하나의 실패하는 테스트만 유지한다. 해당 실패를 성공시킨 다음에 다음 실패하는 케이스를 작성한다.

